from collections import defaultdict

def cards_game(cards_debt):
    total_pot = sum(cards_debt.values())
    max_debt = max(cards_debt.values())
    advantages = {p: max_debt - d for p, d in cards_debt.items()}
    total_adv = sum(advantages.values())
    
    result = {}
    for p, debt in cards_debt.items():
        share = (advantages[p] / total_adv * total_pot) if advantages[p] > 0 else 0
        result[p] = round(share - debt, 2)
    return result

def points_game(points_scores, value_per_point=1):
    players = list(points_scores.keys())
    net = defaultdict(float)
    for i in range(len(players)):
        for j in range(i+1, len(players)):
            p1, p2 = players[i], players[j]
            diff = points_scores[p1] - points_scores[p2]
            if diff > 0:
                net[p1] += diff * value_per_point
                net[p2] -= diff * value_per_point
            elif diff < 0:
                net[p2] += (-diff) * value_per_point
                net[p1] -= (-diff) * value_per_point
    return {p: round(net[p], 2) for p in players}

def fbt_game(front_points, back_points, total_points, pot_value=10):
    net = defaultdict(float)
    for segment in [front_points, back_points, total_points]:
        max_score = max(segment.values())
        winners = [p for p, pts in segment.items() if pts == max_score]
        losers = [p for p in segment if p not in winners]
        if len(winners) == len(segment):  # all tied
            continue
        win_share = pot_value / len(winners)
        lose_share = pot_value / len(losers)
        for w in winners:
            net[w] += win_share
        for l in losers:
            net[l] -= lose_share
    return {p: round(net[p], 2) for p in segment}

def combine_games(*nets):
    players = nets[0].keys()
    return {p: round(sum(net[p] for net in nets), 2) for p in players}

def settle_who_owes_who(net):
    payers = [(p, -amt) for p, amt in net.items() if amt < 0]
    receivers = [(p, amt) for p, amt in net.items() if amt > 0]
    payers.sort(key=lambda x: -x[1])
    receivers.sort(key=lambda x: -x[1])
    result = []
    for payer, owe in payers:
        while owe > 0 and receivers:
            receiver, rec_amt = receivers[0]
            pay_amount = min(owe, rec_amt)
            result.append(f"{payer} pays {receiver}: ${pay_amount:.2f}")
            owe -= pay_amount
            rec_amt -= pay_amount
            if rec_amt == 0:
                receivers.pop(0)
            else:
                receivers[0] = (receiver, rec_amt)
    return result